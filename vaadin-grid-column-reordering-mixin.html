<dom-module id="vaadin-grid-column-reordering-styles">
  <template>
    <style>
      vaadin-grid-table[reordering] .vaadin-grid-cell {
        background: #000;
      }

      :host([reordering]) .vaadin-grid-cell[reorder-status="dragging"] {
        background: var(--primary-color, #000);
      }

      vaadin-grid-table[reordering] .vaadin-grid-cell:not([detailscell]) ::slotted(vaadin-grid-cell-content) {
        transition: opacity 300ms;
        transform: translateZ(0);
        opacity: 0.8;
      }

      #scroller .vaadin-grid-cell[reorder-status="allowed"] ::slotted(vaadin-grid-cell-content) {
        opacity: 1;
      }

      #scroller .vaadin-grid-cell[reorder-status="dragging"] {
        background: var(--primary-color, #000);
      }

      #scroller .vaadin-grid-cell[reorder-status="dragging"] ::slotted(vaadin-grid-cell-content) {
        opacity: 0.95;
      }

      #scroller[no-content-pointer-events] .vaadin-grid-cell ::slotted(vaadin-grid-cell-content) {
        pointer-events: none;
      }

      #reorderghost {
        visibility: hidden;
        position: fixed;
        opacity: 0.5;
        pointer-events: none;
      }
    </style>
  </template>
</dom-module>

<script>
  window.Vaadin = window.Vaadin || {};
  window.Vaadin.Grid = window.Vaadin.Grid || {};

  /**
   * @polymerMixin
   */
  Vaadin.Grid.ColumnReorderingMixin = superClass => class ColumnReorderingMixin extends superClass {

    static get properties() {
      return {
        /**
         * Set to true to allow column reordering.
         */
        columnReorderingAllowed: {
          type: Boolean,
          value: false
        },

        _orderBaseScope: {
          type: Number,
          value: 10000000
        }
      };
    }

    static get observers() {
      return [
        '_updateOrders(_columnTree, _columnTree.*)'
      ];
    }

    ready() {
      super.ready();
      this.addEventListener('dragstart', this._onDragStart);
      this.addEventListener('dragover', this._onDragOver);
      this.addEventListener('dragend', this._onDragEnd);
      this.addEventListener('mouseover', this._onMouseOver);
      this.addEventListener('mouseout', this._onMouseOut);

      this.addEventListener('touchstart', this._onTouchStart);
      this.addEventListener('touchmove', this._onTouchMove);
      this.addEventListener('touchend', this._onTouchEnd);
      this.addEventListener('contextmenu', this._onContextMenu);
    }

    _onContextMenu(e) {
      if (this.$.scroller.hasAttribute('reordering')) {
        e.preventDefault();
      }
    }

    _onTouchStart(e) {
      const cellContent = this._getCellContentByElement(e.target);
      if (!cellContent) {
        return;
      }
      const cell = this._getCellByCellContent(cellContent);
      if (this.columnReorderingAllowed && this.$.header.contains(cell)) {
        this._startTouchReorderTimeout = setTimeout(this._startTouchReorder.bind(this, e, cellContent), 100);
      }
    }

    _startTouchReorder(e, cellContent) {
      this._updateGhost(cellContent);
      this.$.reorderghost.style.visibility = 'visible';
      var dragStart = new CustomEvent('dragstart', {bubbles: true});
      cellContent.dispatchEvent(dragStart);
      this._reorderXY = {
        x: e.touches[0].clientX - cellContent.getBoundingClientRect().left,
        y: e.touches[0].clientY - cellContent.getBoundingClientRect().top
      };
      this._updateGhostPosition(e.touches[0].clientX, e.touches[0].clientY);
    }

    _onTouchMove(e) {
      if (this.$.scroller.hasAttribute('reordering')) {
        e.preventDefault();
        var dragOver = new CustomEvent('dragover', {bubbles: true});
        dragOver.clientX = e.touches[0].clientX;
        dragOver.clientY = e.touches[0].clientY;
        var target = this._contentFromPoint(dragOver.clientX, dragOver.clientY);
        if (target) {
          target.dispatchEvent(dragOver);
        }
        this._updateGhostPosition(e.touches[0].clientX, e.touches[0].clientY);
      } else {
        clearTimeout(this._startTouchReorderTimeout);
      }
    }

    _contentFromPoint(x, y) {
      if (Polymer.Settings.useShadow) {
        var scroller = this.$.scroller;
        scroller.setAttribute('no-content-pointer-events', '');
        var cell = this.shadowRoot.elementFromPoint(x, y);
        scroller.removeAttribute('no-content-pointer-events');
        if (cell) {
          const slot = cell.querySelector('slot');
          return Polymer.dom(slot).getDistributedNodes()[0];
        }
      } else {
        return document.elementFromPoint(x, y);
      }
    }

    _updateGhostPosition(eventClientX, eventClientY) {
      // // This is where we want to position the ghost
      var targetLeft = eventClientX - this._reorderXY.x;
      var targetTop = eventClientY - this._reorderXY.y - 50;
      // Current position
      var _left = parseInt(this.$.reorderghost.style.left || 0);
      var _top = parseInt(this.$.reorderghost.style.top || 0);
      // Reposition the ghost
      var ghostRect = this.$.reorderghost.getBoundingClientRect();
      this.$.reorderghost.style.left = _left - (ghostRect.left - targetLeft) + 'px';
      this.$.reorderghost.style.top = _top - (ghostRect.top - targetTop) + 'px';
    }

    _onTouchEnd(e) {
      clearTimeout(this._startTouchReorderTimeout);
      if (this.$.scroller.hasAttribute('reordering')) {
        e.preventDefault();
        var event = new CustomEvent('dragend', {bubbles: true});
        this.dispatchEvent(event);
        this.$.reorderghost.style.visibility = 'hidden';
      }
    }

    _updateGhost(cellContent) {
      var ghost = this.$.reorderghost;
      ghost.innerText = cellContent.innerText;
      var style = window.getComputedStyle(cellContent);
      ['boxSizing', 'display', 'width', 'height', 'background', 'alignItems', 'padding', 'border', 'flex-direction', 'overflow']
      .forEach(function(propertyName) {
        ghost.style[propertyName] = style[propertyName];
      }, this);
      return ghost;
    }

    _onMouseOver(e) {
      const cellContent = this._getCellContentByElement(e.target);
      if (!cellContent) {
        return;
      }
      const cell = this._getCellByCellContent(cellContent);
      if (this.columnReorderingAllowed && this.$.header.contains(cell)) {
        cellContent.setAttribute('draggable', 'true');
      }
    }

    _onMouseOut(e) {
      const cellContent = this._getCellContentByElement(e.target);
      if (!cellContent) {
        return;
      }
      cellContent.removeAttribute('draggable');
    }

    _updateOrders(columnTree, splices) {
      if (columnTree === undefined || splices === undefined) {
        return;
      }

      // Set order numbers to top-level columns
      columnTree[0].forEach((column, index) => {
        column._order = (index + 1) * this._orderBaseScope;
      });
    }

    _onDragStart(e) {
      // We allow “dragstart” to start reordering only directly on
      // <vaadin-grid-cell-content> elements. Otherwise, any cell content with
      // `draggable="true"` attribute can start column reordering, issue #895.
      if (e.target.localName !== 'vaadin-grid-cell-content') {
        return;
      }

      const cell = this._getCellByCellContent(e.target);
      if (cell) {
        this.$.scroller.setAttribute('reordering', '');
        this._draggedColumn = cell._column;
        this._setSiblingsReorderStatus(this._draggedColumn, 'allowed');
        this._draggedColumn._reorderStatus = 'dragging';

        if (e.dataTransfer) {
          // Need to set any data to enable D&D on Firefox
          e.dataTransfer.setData('text', '');
          e.dataTransfer.effectAllowed = 'move';
        }

        this._autoScroller();
      }
    }

    _setSiblingsReorderStatus(column, status) {
      Array.prototype.filter.call(column.parentNode.children, child => {
        return /column/.test(child.localName) && this._isSwapAllowed(child, column);
      }).forEach(sibling => {
        sibling._reorderStatus = status;
      });
    }

    _onDragOver(e) {
      if (!this._draggedColumn) {
        // Reordering didn’t start. Skip this event.
        return;
      }

      // “dragover” can happen both on and inside <vaadin-grid-cell-content>,
      // so we look through the event path.
      const cellContent = e.composedPath().filter(el => {
        return el.localName === 'vaadin-grid-cell-content';
      })[0];
      if (!cellContent) {
        return;
      }

      e.preventDefault();
      const targetCell = this._getCellByCellContent(cellContent);
      const targetColumn = this._getTargetColumn(targetCell, this._draggedColumn);

      if (targetColumn &&
        this._isSwapAllowed(this._draggedColumn, targetColumn) &&
        this._isSwappableByPosition(targetColumn, e.clientX)) {
        this._swapColumnOrders(this._draggedColumn, targetColumn);
      }

      this._lastDragClientX = e.clientX;
    }

    _autoScroller() {
      if (this._lastDragClientX) {
        const rightDiff = this._lastDragClientX - this.getBoundingClientRect().right + 50;
        const leftDiff = this.getBoundingClientRect().left - this._lastDragClientX + 50;

        if (rightDiff > 0) {
          this.$.table.scrollLeft += rightDiff / 10;
        } else if (leftDiff > 0) {
          this.$.table.scrollLeft -= leftDiff / 10;
        }
        this._scrollHandler();
      }

      if (this._draggedColumn) {
        this.async(this._autoScroller, 10);
      }
    }

    _onDragEnd(e) {
      if (!this._draggedColumn) {
        // Reordering didn’t start. Skip this event.
        return;
      }

      this.$.scroller.removeAttribute('reordering');
      this._draggedColumn._reorderStatus = '';
      this._setSiblingsReorderStatus(this._draggedColumn, '');
      this._draggedColumn = null;
      this._lastDragClientX = null;
    }

    _isSwapAllowed(column1, column2) {
      if (column1 && column2) {
        const differentColumns = column1 !== column2;
        const sameParent = column1.parentElement === column2.parentElement;
        const sameFrozen = column1.frozen === column2.frozen;
        return differentColumns && sameParent && sameFrozen;
      }
    }

    _isSwappableByPosition(targetColumn, clientX) {
      const targetCell = Array.prototype.filter.call(this.$.header.querySelectorAll('.vaadin-grid-cell'), cell => {
        return cell._column === targetColumn;
      })[0];
      const sourceCellRect = this.$.header.querySelector('[reorder-status=dragging]').getBoundingClientRect();

      if (targetCell.getBoundingClientRect().left > sourceCellRect.left) {
        return clientX > targetCell.getBoundingClientRect().right - sourceCellRect.width;
      } else {
        return clientX < targetCell.getBoundingClientRect().left + sourceCellRect.width;
      }
    }

    _swapColumnOrders(column1, column2) {
      const _order = column1._order;
      column1._order = column2._order;
      column2._order = _order;
      this._updateLastFrozen();
      // this._updateLastColumn();
    }

    _getTargetColumn(targetCell, draggedColumn) {
      if (targetCell && draggedColumn) {
        let candidate = targetCell._column;
        while (candidate.parentElement !== draggedColumn.parentElement && candidate !== this) {
          candidate = candidate.parentElement;
        }
        if (candidate.parentElement === draggedColumn.parentElement) {
          return candidate;
        } else {
          return targetCell._column;
        }
      }
    }

  };
</script>
