<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE
The complete set of authors may be found at http://polymer.github.io/AUTHORS
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS
-->

<script>
  var firefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
  var defaultCellWidth = 100;

  function flushGrid(grid) {
    grid._observer.flush();
    if (grid._debounceScrolling) {
      grid._debounceScrolling.flush();
    }
    Polymer.flush();
    if (grid._debouncerLoad) {
      grid._debouncerLoad.flush();
    }
  }

  function getCell(grid, index) {
    return grid.$.items.querySelectorAll('[part~="cell"]')[index];
  }

  function getFirstCell(grid) {
    return getCell(grid, 0);
  }

  function getScrollbarWidth() {
    // Create the measurement node
    var scrollDiv = document.createElement('div');
    scrollDiv.style.width = '100px';
    scrollDiv.style.height = '100px';
    scrollDiv.style.overflow = 'scroll';
    scrollDiv.style.position = 'absolute';
    scrollDiv.style.top = '-9999px';
    document.body.appendChild(scrollDiv);
    // Get the scrollbar width
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;

    // Delete the DIV
    document.body.removeChild(scrollDiv);
    return scrollbarWidth;
  }

  function infiniteDataProvider(params, callback) {
    callback(Array.apply(null, Array(params.pageSize)).map(function(item, index) {
      return {
        value: 'foo' + index
      };
    }));
  }

  function findElementInList(container, selector) {
    var i = 0;
    var children = container._children;
    var ms = Polymer.DomApi.matchesSelector;

    for (; i < children.length; i++) {
      if (children[i].nodeType === Node.ELEMENT_NODE && ms.call(children[i], selector)) {
        return children[i];
      }
    }
    return null;
  }

  function listenOnce(element, eventName, callback) {
    var listener = function(e) {
      element.removeEventListener(eventName, listener);
      callback(e);
    };
    element.addEventListener(eventName, listener);
  }

  function buildItem(index) {
    return {
      index: index
    };
  }

  function buildDataSet(size) {
    var data = [];
    while (data.length < size) {
      data.push(buildItem(data.length));
    }
    return data;
  }

  function scrollToEnd(grid, callback) {
    grid.scrollToIndex(grid.size - 1);

    // Ensure rows are in order
    grid._debounceScrolling.flush();
    flushGrid(grid);
    if (callback) {
      callback();
    }
  }

  function simulateScroll(config) {
    var list = config.list;
    var target = config.target;
    var delay = config.delay || 1;
    var contribution = Math.abs(config.contribution) || 10;
    // scroll back up
    if (target < list.scrollTop) {
      contribution = -contribution;
    }

    function scrollHandler() {
      setTimeout(function() {
        var minScrollTop = 0;
        var maxScrollTop = list.scrollHeight - list.offsetHeight;

        config.onScroll && config.onScroll();

        if (list.scrollTop < target && contribution > 0 && list.scrollTop < maxScrollTop) {
          list.scrollTop = Math.min(maxScrollTop, list.scrollTop + contribution);

        } else if (list.scrollTop > target && contribution < 0 && list.scrollTop > minScrollTop) {
          list.scrollTop = Math.max(minScrollTop, list.scrollTop + contribution);

        } else {
          list.removeEventListener('scroll', scrollHandler);
          list.scrollTop = target;
          config.onScrollEnd && config.onScrollEnd();
        }
      }, delay);
    }
    list.addEventListener('scroll', scrollHandler);
    scrollHandler();
  }

  function getGridRowFromIndex(grid, index) {
    return Math.floor(index / grid._itemsPerRow);
  }

  function getFirstVisibleItem(grid) {
    var visibleRows = getVisibleItems(grid);
    if (visibleRows.length) {
      return visibleRows[0];
    }
    return null;
  }

  function getLastVisibleItem(grid) {
    var visibleRows = getVisibleItems(grid);
    if (visibleRows.length) {
      return visibleRows.pop();
    }
    return null;
  }

  function getVisibleItems(grid) {
    // TODO: make sure rows are ordered in the visible order
    grid.flushDebouncer('vaadin-grid-scrolling');
    var rows = grid.$.items.children;
    var visibleRows = [];
    for (var i = 0; i < rows.length; i++) {
      if (isVisible(rows[i])) {
        visibleRows.push(rows[i]);
      }
    }
    return visibleRows;
  }

  // http://stackoverflow.com/a/15203639/1331425
  function isVisible(el) {
    var top = el.offsetTop;
    var left = el.offsetLeft;
    var width = el.offsetWidth;
    var height = el.offsetHeight;

    while(el.offsetParent) {
      el = el.offsetParent;
      top += el.offsetTop;
      left += el.offsetLeft;
    }

    return (
      top < (window.pageYOffset + window.innerHeight) &&
      left < (window.pageXOffset + window.innerWidth) &&
      (top + height) > window.pageYOffset &&
      (left + width) > window.pageXOffset
    );
  }

  function isFullOfItems(list) {
    var listRect = list.getBoundingClientRect();
    var listHeight = listRect.height - 1;
    var item, y = listRect.top + 1;
    // IE 10 & 11 doesn't render propertly :(
    var badPixels = 0;
    while (y < listHeight) {
      item = document.elementFromPoint(listRect.left + 100, y);

      if (!item) {
        badPixels++;
      }
      y++;
      if (badPixels > 2) {
        return false;
      }
    }
    return true;
  }

  function checkRepeatedItems(list) {
    var listRect = list.getBoundingClientRect();
    var listHeight = list.offsetHeight;
    var listItems = {};

    return function() {
      var itemKey;
      var y = listRect.top;
      while (y < listHeight) {
        var item = document.elementFromPoint(listRect.left + 100, y + 2);
        itemKey = item.textContent || item.innerText;

        if (item.parentNode && item.parentNode._templateInstance) {
          if (listItems[itemKey] && listItems[itemKey] != item) {
            return true;
          }
          listItems[itemKey] = item;
        }
        y += item.offsetHeight;
      }
      return false;
    };
  }

  function getRows(container) {
    return container.querySelectorAll('tr');
  }

  function getRowCells(row) {
    return Array.prototype.slice.call(Polymer.dom(row).querySelectorAll('[part~="cell"]'));
  }

  function getCellContent(cell) {
    return cell ? cell.querySelector('slot').assignedNodes()[0] : null;
  }

  function getHeaderCellContent(grid, row, col) {
    var container = grid.$.header;
    return getContainerCellContent(container, row, col);
  }

  function getBodyCellContent(grid, row, col) {
    var container = grid.$.items;
    return getContainerCellContent(container, row, col);
  }

  function getContainerCellContent(container, row, col) {
    return getCellContent(getContainerCell(container, row, col));
  }

  function getContainerCell(container, row, col) {
    var rows = getRows(container);
    var cells = getRowCells(rows[row]);
    return cells[col];
  }

  function dragStart(source) {
    source.parentElement._touchDevice = false;
    var sourceRect = source.getBoundingClientRect();
    fire('track', {
      x: sourceRect.left + sourceRect.width / 2 + 1,
      y: sourceRect.top,
      state: 'start'
    }, {
      node: source,
      bubbles: true
    });
  }

  function dragOver(source, target, clientX) {
    dragStart(source);
    var targetRect = target.getBoundingClientRect();
    fire('track', {
      x: clientX || targetRect.left + targetRect.width / 2 + 1,
      y: targetRect.top,
      state: 'track'
    }, {
      node: source,
      bubbles: true
    });
  }

  function dragAndDropOver(source, target) {
    dragOver(source, target);
    fire('track', {
      x: 0,
      y: 0,
      state: 'end'
    }, {
      node: source,
      bubbles: true
    });
  }

  function makeSoloTouchEvent(type, xy, node) {
    var touches = [{
      identifier: 0,
      target: node,
      clientX: xy.x,
      clientY: xy.y
    }];
    var touchEventInit = {
      touches: touches,
      targetTouches: touches,
      changedTouches: touches
    };
    var event = new CustomEvent(type, {bubbles: true, cancelable: true});
    for (var property in touchEventInit) {
      event[property] = touchEventInit[property];
    }
    node.dispatchEvent(event);
    return event;
  }

  function click(element) {
    fire('click', {}, {
      node: element,
      bubbles: true
    });
  }

  function flushColumns(grid) {
    Array.prototype
      .forEach.call(grid.querySelectorAll('vaadin-grid-column, vaadin-grid-column-group'),
      function(col) {
        col._templateObserver.flush();
      });
  }

  function fire(type, detail, options) {
    options = options || {};
    detail = (detail === null || detail === undefined) ? {} : detail;
    const event = new Event(type, {
      bubbles: options.bubbles === undefined ? true : options.bubbles,
      cancelable: Boolean(options.cancelable),
      composed: options.composed === undefined ? true : options.composed
    });
    event.detail = detail;
    const node = options.node || this;
    node.dispatchEvent(event);
    return event;
  }

</script>
